{
    "collab_server" : "",
    "contents" : "# Data visualisation\n\n\nCette partie va vous apprendre à visualiser vos premières données sous R avec ggplot2. Une des façons de mettre en forme vos données est d'utiliser la librairie ggplot2, qui utilise la [grammaire des graphiques](http://vita.had.co.nz/papers/layered-grammar.pdf). Elle considère un graphique comme des données composées d'esthétiques de formes géométrique.  Un graphique se décompose d'élément simple comme la position d'un objet géométrique sur l'axe des ordonnées, des abscisses, de sa couleur et de sa taille ... etc \n```{r,echo=F,fig.show='hold',message=FALSE, echo=F, message=FALSE, warning=FALSE, show.figure=\"hold\"}\n \n# Packages ----------------------------------------------------------------\n \nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"sp\")\nlibrary(\"rgeos\")\n \n \n# Funs --------------------------------------------------------------------\n \ncoord_circle <- function(centre = c(0, 0), r = 1, n = 1000) {\n  data_frame(\n    x = seq(from = 0 - r, to = 0 + r, length.out = n %/% 2),\n    y = sqrt(r^2 - x^2)\n  ) %>% bind_rows(., -.) %>%\n    mutate(x = x + centre[1], y = y + centre[2])\n}\n \n \ncreate_poly <- function(...) {\n  args <- list(...)\n  SpatialPolygons(\n    lapply(\n      X = seq_along(args),\n      FUN = function(x) {\n        Polygons(list(Polygon(as.data.frame(args[[x]]))), names(args)[x])\n      }\n    )\n  )\n}\n \n \nechancrure <- function(to_var, by_var, p = 0.1) {\n  ind <- which(by_var >= -0.08 & by_var <= 0.08 & to_var > 0)\n  to_var[ind] <- to_var[ind] - p\n  ind <- which(by_var >= -0.08 & by_var <= 0.08 & to_var < 0)\n  to_var[ind] <- to_var[ind] + p\n  return(to_var)\n}\n \n \n \n# BB-8 geometries ---------------------------------------------------------\n \n \n# droid_body -------------------------------------------------------------------\n \n# shape of the droid_body : two circles and a vertical line\ndroid_body <- coord_circle(centre = c(0, 0), r = 1)\ndroid_body$xvert <- 0\ndroid_body$yvert <- droid_body$x\ndroid_body <- bind_cols(\n  droid_body,\n  coord_circle(centre = c(0, 0), r = 0.35, n = nrow(droid_body)) %>% select(xint = x, yint = y)\n)\n \n\n# grey shapes in the central inner circle\ndroid_body_rect <- data_frame(\n  x = c(-0.5, 0.5, 0.5, -0.5, c(-0.5, 0.5, 0.5, -0.5) - 0.2, c(-0.5, 0.5, 0.5, -0.5) + 0.2),\n  y = c(-0.6, 0.4, 0.6, -0.4, c(-0.6, 0.4, 0.6, -0.4) + 0.2, c(-0.6, 0.4, 0.6, -0.4) - 0.2),\n  group = rep(1:3, each = 4)\n)\n# a polygon for calculate the intersection between the grey shapes and the inner circle\npolyrect <- create_poly(\n  \"polyrect1\" = droid_body_rect[droid_body_rect$group == 1, 1:2],\n  \"polyrect2\" = droid_body_rect[droid_body_rect$group == 2, 1:2],\n  \"polyrect3\" = droid_body_rect[droid_body_rect$group == 3, 1:2]\n)\n \npolycircle <- create_poly(\n  \"polycircle\" = droid_body[, c(\"xint\", \"yint\")]\n)\n# plot(polyrect); plot(polycircle, add = TRUE)\npolyrect <- gIntersection(spgeom1 = polyrect, spgeom2 = polycircle)\n# plot(polyrect); plot(polycircle, add = TRUE)\n \n# fortify the polygon for ggplot\ndroid_body_rect <- fortify(polyrect)\n \n \n# Central ring (orange)\nring <- coord_circle(centre = c(0, 0), r = 0.4)\nring$y <- echancrure(to_var = ring$y, by_var = ring$x, p = 0.1)\nring$x <- echancrure(to_var = ring$x, by_var = ring$y, p = 0.1)\nring <- bind_rows(\n  ring %>% mutate(group = (x >= 0) * 1),\n  coord_circle(centre = c(0, 0), r = 0.55, n = nrow(ring)) %>% mutate(y = -y, group = (x >= 0) * 1)\n) %>%\n  filter(group == 1) # oups something went wrong\nring <- bind_rows(ring, ring %>% mutate(x = -x, group = 2))\n \n \n \n \n# ring left and right\n# we make a copy of the right part of the central ring\nring_left <- ring %>% filter(group == 1)\n# and we shift the ring center\nring_left$x <- ring_left$x - 1.3\n \n# the same ...\nring_right <- ring %>% filter(group == 2)\nring_right$x <- ring_right$x + 1.3\n \n# we creta a polygon for the intersection with the droid_body circle\npolyring <- create_poly(\n  \"polyring_g\" = ring_left[, c(\"x\", \"y\")],\n  \"polyring_d\" = ring_right[, c(\"x\", \"y\")]\n)\n \npolydroid_body <- create_poly(\"polydroid_body\" = droid_body[, c(\"x\", \"y\")])\n \n# plot(polyring); plot(polydroid_body, add = TRUE)\n \npolyring <- gIntersection(spgeom1 = polyring, spgeom2 = polydroid_body)\nfort_ring <- fortify(polyring)\n \n \n# the horizontal line of the body (in two parts)\nligne_hori <- data_frame(\n  x = c(-1, range(ring$x), 1),\n  y = 0,\n  group = c(1, 1, 2, 2)\n)\n \n \n# droid head --------------------------------------------------------------------\n \ndroid_head <- coord_circle(centre = c(0, 1.02), r = 0.52) %>%\n  filter(y >= 1.02) %>%\n  mutate(group = 1, fill = \"white\", col= \"black\") %>%\n  bind_rows(\n    data_frame(\n      x = c(-0.52, -0.4, 0.4, 0.52),\n      y = c(1.02, 0.95, 0.95, 1.02),\n      group = 2, fill = \"white\", col= \"black\"\n    )\n  )\n \n \n \n# Grey bars in droid's head\npoly_head_grey <- create_poly(\n  \"poly_head_grey_haut\" = data_frame(\n    x = c(-0.52, 0.52, 0.52, -0.52),\n    y = c(1.44, 1.44, 1.51, 1.51)\n  ),\n  \"poly_head_grey_bas\" = data_frame(\n    x = c(-0.52, 0.52, 0.52, -0.52),\n    y = c(1.02, 1.02, 1.07, 1.07)\n  )\n)\n \npolydroid_head <- create_poly(\"polydroid_head\" = droid_head[droid_head$group == 1, c(\"x\", \"y\")])\n \npoly_head_grey <- gIntersection(spgeom1 = poly_head_grey, spgeom2 = polydroid_head)\nfort_droid_headrectgris <- fortify(poly_head_grey)\n \n \n \n# orange bars\npoly_head_orange <- create_poly(\n  \"poly_head_orange1\" = data_frame(\n    x = c(-0.52, 0.52, 0.52, -0.52),\n    y = c(1.38, 1.38, 1.42, 1.42)\n  ),\n  \"poly_head_orange2\" = data_frame(\n    x = c(-0.35, -0.35, -0.2, -0.2),\n    y = c(1.07, 1.15, 1.15, 1.07)\n  ),\n  \"poly_head_orange3\" = data_frame(\n    x = c(-0.55, -0.55, -0.45, -0.45),\n    y = c(1.07, 1.15, 1.15, 1.07)\n  ),\n  \"poly_head_orange4\" = data_frame(\n    x = c(0.44, 0.44, 0.47, 0.47),\n    y = c(1.07, 1.15, 1.15, 1.07)\n  )\n)\n \npoly_head_orange <- gIntersection(spgeom1 = poly_head_orange, spgeom2 = polydroid_head)\nfort_droid_headrectorange <- fortify(poly_head_orange)\n \n \npolygones_droid_head <- bind_rows(\n  fort_droid_headrectgris %>% select(-piece) %>%\n    mutate(group = as.numeric(as.character(group)), fill = \"#8E8E9C\", col= \"black\"),\n  fort_droid_headrectorange %>% select(-piece) %>% \n    mutate(group = as.numeric(as.character(group)) * 2, fill = \"#DF8D5D\", col= \"black\")\n)\n \n \n# Eyes\ndroid_eyes <- bind_rows(\n  coord_circle(centre = c(0, 1.35), r = 0.14) %>% mutate(group = 1, fill = \"white\", col = \"white\"),\n  coord_circle(centre = c(0, 1.35), r = 0.12) %>% mutate(group = 2, fill = \"white\", col = \"black\"),\n  coord_circle(centre = c(0, 1.35), r = 0.10) %>% mutate(group = 3, fill = \"grey40\", col = \"grey40\"),\n  coord_circle(centre = c(0, 1.35), r = 0.08) %>% mutate(group = 4, fill = \"black\", col = \"black\"),\n  coord_circle(centre = c(0, 1.16), r = 0.04) %>% mutate(group = 5, fill = \"#76B1DE\", col = \"black\"),\n  coord_circle(centre = c(0.25, 1.20), r = 0.08) %>% mutate(group = 6, fill = \"black\", col = \"black\"),\n  coord_circle(centre = c(0.25, 1.20), r = 0.07) %>% mutate(group = 7, fill = \"white\", col = \"black\"),\n  coord_circle(centre = c(0.25, 1.20), r = 0.06) %>% mutate(group = 8, fill = \"grey40\", col = \"grey40\"),\n  coord_circle(centre = c(0.25, 1.20), r = 0.04) %>% mutate(group = 9, fill = \"black\", col = \"black\")\n)\n \neye_line <- data_frame(\n  x = 0,\n  y = c(1.07, 1.16-0.04)\n)\n \n# Antennas\nantennas <- data_frame(\n  x = c(0.01, 0.01, 0.10, 0.10),\n  y = c(sqrt(0.52^2 - 0.01^2) + 1.02, sqrt(0.52^2 - 0.01^2) + 1.02 + 0.15,\n        sqrt(0.52^2 - 0.1^2) + 1.02, sqrt(0.52^2 - 0.1^2) + 1.02 + 0.25),\n  group = c(1, 1, 2, 2)\n)\n \n \n# bb-8/ggplot2 ------------------------------------------------------------\n \nbb8 <- ggplot(data = droid_body) +\n  coord_fixed() +\n  geom_polygon(mapping = aes(x = x, y = y), fill = \"white\", col = \"black\") +\n  geom_polygon(data = droid_body_rect, mapping = aes(x = long, y = lat, group = group), fill = \"#8E8E9C\") +\n  geom_path(mapping = aes(x = xvert, y = yvert)) +\n  geom_path(mapping = aes(x = xint, y = yint)) +\n  geom_polygon(data = ring, mapping = aes(x = x, y = y, group = group), fill = \"#DF8D5D\", col = \"#DF8D5D\") +\n  geom_path(data = ligne_hori, mapping = aes(x = x, y = y, group = group)) +\n  geom_polygon(data = fort_ring , mapping = aes(x = long, y = lat, group = group), fill = \"#DF8D5D\") +\n  geom_polygon(data = droid_head, mapping = aes(x = x, y = y, group = group, fill = fill, col = col)) +\n  geom_polygon(data = polygones_droid_head, mapping = aes(x = long, y = lat, group = group, fill = fill, col = col)) +\n  geom_polygon(data = droid_eyes, mapping = aes(x = x, y = y, group = group, fill = fill, col = col)) +\n  scale_fill_identity() + scale_color_identity() +\n  geom_line(data = eye_line, mapping = aes(x = x, y = y)) +\n  geom_line(data = antennas, mapping = aes(x = x, y = y, group = group), col = \"black\")\n \n \n# bb8\n# or\nbb8 + theme_void() +labs(caption=\"http://www.r-graph-gallery.com/144-droid-bb-8-data-art/\")\n \n \n \n# save --------------------------------------------------------------------\n \n# ggsave(filename = \"#144_bb8_ggplot2.png\", plot = bb8, width = 6, height = 8)\n# ggsave(filename = \"#144_bb8_ggplot2_void.png\", plot = bb8 + theme_void(), width = 6, height = 8)\n```\n\nUn graphique, en plus du rendu visuel attractif,  en data science sert généralement à répondre à une question. Par exemple\n\n* Quelle est la forme de mes données ? \n* Quelle est la relation entre mes jeux de données ? linéaires, non-linéaires ...\n\n## Premier graphe avec ggplot2\n\nNous allons utiliser des données dèja disponible dans R. \n\n```{r}\n?cars\nclass(cars)\n```\n\nPuis, nous allons charger la librairie ggplot2 afin de disposer des fonctions de la librairie et créer notre premier graphique. \n\n```{r}\nlibrary(ggplot2)\n\nggplot(cars) + geom_point(aes(x=speed,y=dist))\n```\n```{r}\nggplot(cars) + geom_point(aes(x=speed,y=dist,size = speed))\n\n```\n```{r}\nggplot(cars) + geom_point(aes(x=speed,y=dist),size=4)\n\n```\n```{r}\nggplot(cars) + geom_point(aes(x=speed,y=dist,alpha=speed))\n\n```\n\n```{r}\nggplot(cars) + geom_point(aes(x=speed,y=dist,colour=speed<15))\n\n```\n```{r}\nggplot(cars,aes(x=speed,y=dist)) + geom_point(aes(colour=speed<15)) + geom_smooth(method = \"lm\")\n\n```\n```{r}\nggplot(cars) + geom_point(aes(x=speed,y=dist,shape=speed<15),size=4)\n```\n\n```{r}\n\n# Operator IF ELSE\nif (!require(\"ggpmisc\")){\n  install.packages(\"ggpmisc\")\n} else {\n  \n}\n\n# Le package ggmisc permet facilement d'afficher l'équation du modèle linéaire ainsi que \n#des métrique d'erreur\nma_formule = y ~ x -1\n#ma_formule = y ~ x\n\n#ma_formule = y ~ poly(x = x,degree =2)\n\nggplot(cars,aes(x=speed,y=dist)) + geom_point(aes(colour=speed<15)) + geom_smooth(method = \"lm\",formula = ma_formule ) +  stat_poly_eq(aes(label =paste0(\"atop(\",..eq.label..,\",\",paste(..adj.rr.label..,..AIC.label..,..BIC.label..,sep=\"~\"),\")\")),formula =ma_formule, parse = TRUE)\n\n```\n\n**Définition**\n\nLe *coeffiecient de détermination* pour des observations $y$ et ses valeurs modélisées $f$ est défini comme : \n\n$$R^2  =1- \\frac{\\sum_i (y_i-f_i)^2}{\\sum_i (y_i-\\bar{y})^2}$$\n$$R^2_{adjusted} = {1-(1-R^2){n-1 \\over n-p-1}} = {R^2-(1-R^2){p \\over n-p-1}}$$\n\n avec $p$ le nombre de valeurs explicatives et $n$ la taille de $y$.\n \n Plus $R^2$ est grand plus le modèle, qui prédit $f$, explique la variance de $y$.  \n\n*AIC* & *BIC*\n\nLe critère d'information d'Akaike (AIC) et le critère d'information bayésien (BIC) sont tous les deux une mesure de la qualité d'un modèle statistique.\n\nIl est possible d'augmenter la vraisemblance du modèle statistique testé en ajoutant plusieurs paramètres. Le critère d'information d'Akaike, tout comme le critère d'information bayésien (BIC), permet de pénaliser les modèles en fonction du nombre de paramètres afin de diminuer l'over fiting. On choisit alors le modèle avec le critère d'information d'Akaike ou bayésien le plus faible. Ils sont définis comme : \n\n\n\n$$AIC = 2k - 2\\ln(L)$$\n$$BIC = -2\\ln(L) + \\ln(n)k$$\nAvec avec $n$ le nombre d'observations dans l'échantillon étudié et $k$ le nombre de paramètres et $L$ la fonction de vraisemblance.\n\n**Exercice 1**\n\n*Nous avons vu plusieurs modèles la dernière fois pour modéliser la vitesse et la distance de freinage. En fonction des différentes métriques d'erreurs présentées au dessus. Séléctionner le modèle satistique le plus pertinant en modifiant* 'ma_formule.'\n\n## Ggplot2\n**Définition**\nUne librairie R de visualisation de données développée par Hadley Wickham en 2005 selon les principes développés par Leland Wilkinson dans son ouvrage The Grammar of Graphics\n\n   $$ Plot = data +Geometry( Aesthetics  )$$\n    \n  * Aesthetics (aes) : les couleurs, les tailles, les formes, les labels mais aussi les données en x et en y\n  * Geometry (geom_ …) va regrouper les options concernant les types de graphique (line, point, histogramme, heatmap, boxplot, etc.)\n```{r, eval=FALSE}\nggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))\n\n```\n\n### Première étape Data Mining \n\nNous allons  utiliser des données de l'objet `mpg`, qui est préchargé dans le paquet ggplot. \n\n#### Information sur les données \nIl faut connaître ces données. \n\n**Exercice 2**\n\n* *Quelle est le type de cet objet ?*\n* *Que contient cet objet ? *\n* *Que siginifie `displ` et `hwy` ?*\n* *Quelle est le type des vecteurs hwy, displ et manufacturer ? *\n* *Combien y-a-t il de ligne et de colonne dans mpg ?*\n\n#### Nuage de points \n\nUn nuage de points ou un scatterplot est le graphe le plus utilisé en statistique.\n\n**Exercice 3**\n\n\nReproduisez le scatterplot ci-dessous entre hwy et displ puis entre hwy et cyl; entre class et drv. Expliquez pourquoi ces graphes ont ces formes.\n\n```{r,echo=FALSE,fig.show='hold',out.width='33%'}\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy))\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = cyl))\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = class, y = drv))\n```\n\n\n### L'esthétique gaphique\n\nDans un graphe, le but est de mettre en évidence les caractéristiques des données que l'on souhaite développer et qui ne sont généralement pas visible à l’œil nu.   \n```{r,echo=FALSE}\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy,color=(class==\"2seater\"|(class==\"midsize\"&displ>5)),size=(class==\"2seater\"|(class==\"midsize\"&displ>5))))+\n  scale_color_manual(values = c(\"black\",\"red\"),guide=F)+scale_size_manual(values = c(2,4),guide=F)\n\n```\n\n\n\nDans ce scatterplot, les points en rouge ont l'air d'être particulier par rapport à l'ensemble de l'échantillon.\nLa fonction aes() *aesthetic* permet de définir l'axe des x et des y mais aussi la taille, les couleurs, le type et la transparence des formes géométriques du graphe. \n\n**Exercice 4**\n\n * Dessiner un nuage de points pour chaque esthétique aes(x,y,shape = class ) définit par la colonne `class` pour les couleurs *color*, les formes *shape*, la taille *size*, et la transparence *alpha*.\n \n```{r,echo=FALSE, echo=FALSE, message=FALSE, warning=FALSE}\n ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, color = class))\n  ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, size = class)) \n \n```\n```{r,echo=FALSE, echo=FALSE, message=FALSE, warning=FALSE}\n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, shape = class)) \n    \n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, alpha = class)) \n```\n\n * Pourquoi il y a des points qui ont disparu de la classe suv dans le graphique où l'on dessine le nuage avec différentes formes de point `aes(x,y,shape=class)` ?\n \n \n * Quel est le problème dans ce code ?\n```{r,eval=FALSE}\n ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy,colour=\"class\"))\n```\n\n  * Quelle est la différence avec les graphiques précédent et quel est l'impact sur les graphes du code ci-dessous ?\n```{r,eval=FALSE}\n ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy),colour=\"blue\")\n  \n   ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy),size=10)\n```\n\n  \n \n * Que faut il ajouter pour corriger le graphique  ? ([indice](http://www.cookbook-r.com/Graphs/Shapes_and_line_types/) et regardez le message de warning afficher en console)\n\n```{r,echo=FALSE}\n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, shape = class,fill=class)) \n```\n\n\n```{r,echo=FALSE}\n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy, shape = class,fill=class)) +scale_shape_manual(values=seq(1,7))\n```\n\n## Erreurs courantes \n\nVous avez depuis le début fait des erreurs ou lancé des commandes qui ne marchent pas. Ne vous inquiétiez pas tous les jours même les plus grands programmeurs, hackers et data scientiste en font aussi. \n\nCi dessous la liste recense des erreurs communes, et décrit la manière de les éviter : \n\n* `(` vérifier que toutes les parenthèses se ferment `)`\n*  `\"\"` vérifier  la même chose pour les guillemets\n*  Vérifier si votre ligne de commande ne finisse pas par un `+` ou qu'elle ne commence pas par `>` ou `+`  \n\nSi vous êtes toujours bloqués, n'hésitez pas à demander de l'aide à R. La commande `?function_name` demande à R de l'aide pour une fonction spécifique. La commande `??function_name`comprend une recherche plus large de cette fonction si la première commande `?` ne marche pas.   \n\nLa lecture du message d'erreur est utile. Si le message n'est pas clair, vous avez toujours la possibilité de le Googler. Vous pourriez tomber sur quelqu'un qui a posté sur starck overflow par exemple la même erreur avec la solution au problème. \n\n## Panneaux \n\nUne des forces de ggplot2 est de pouvoir facilement faire plusieurs graphes en fonction d'une des colonnes de la dataframe du graphe. Par exemple, pour reprendre le travail ci-dessus nous pouvons avoir envie de faire un scatterplot pour différentes classes de voitures. Il faut utiliser la fonction `facet_wrap()` avec comme argument une formule.\n\n```{r}\n\n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +   facet_wrap(facets = ~ class)\n\n```\n\nPar contre, si vous souhaitez séparer votre graphique en fonction de deux variables alors il faut utiliser la fonction `facet_grid()`.\n\n```{r}\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  facet_grid(year ~ cyl)\n\n```\n\n\n**Exercice 5**\n\n\n1. A quoi sert le `.` dans la formule de facet_grid ? (Testez les exemples en dessous)\n```{r, eval = F}\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n```\n\n2. Quelles sont les avantages et les désavantages d'utiliser les fonctions `facet` par rapport à une esthétique `aes(x,y,color=...)` ?\n\n```{r,eval=F}\n    ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) +   facet_wrap(facets = ~ class)\n\n  ggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy,color=class)) \n\n```\n\n3. Quelles sont les différences entre `facet_grid()` et `facet_wrap()` ? (Indice utiliser `?`)\n\n\n### Géométries\n\n\n```{r,fig.show = 'hold',eval=T,echo=F}\n\nggplot(cars) + geom_point(aes(speed,dist))\nggplot(cars) + geom_smooth(aes(speed,dist))\n\n```\n\n**Quelles est la différence entre ces deux graphiques ? **\n\n\nIl y a plus de 30 types de géométrie dans ggplot2. Pour les connaîtres, l'aide mémoire R sur ggplot2  et les extensions de ggplot2 https://www.ggplot2-exts.org sont à lire. Chaque géométrie a ses propres esthétiques. Par exemple, les géométries avec des lignes n'ont pas d'esthétiques `shape`. Mais elles ont `linetype` et `group` en plus. \n\n```{r}\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))\n```\n\nOn peut combiner les géométries pour que le graphe soit plus clair. \n\n```{r}\nggplot(data = mpg) + \n  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))+\n  geom_point(mapping = aes(x = displ, y = hwy, color = drv))\n\n```\n\nL'esthétique `group` permet de dessiner plusieurs lignes en fonction d'une colonne de la data frame.\n\n```{r,fig.show=\"hold\"}\nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy))\n              \nggplot(data = mpg) +\n  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))\n```\n\n\nPour synthétiser le code, il est possible d'ajouter les esthétiques dans la fonction `ggplot(data=my_data,aes())`. Chaque géométrie prendra alors les esthétiques dans `ggplot(aes(...))`. On peut toujours ajouter des esthétiques spécifiques dans chaque géométrie.\n\n![Géométrie basique](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-geoms-1.png)\n![](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-geoms-2.png)\n![](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-geoms-3.png)\n![](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-geoms-4.png)\n\n**Exercices 6**\n\n* Que font les options `se=FALSE` et `show.legend=FALSE` ?\n\n```{r,eval=FALSE}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + \n  geom_point(show.legend=F) + \n  geom_smooth(se = FALSE,show.legend=FALSE)\n\n```\n\n* Ces deux graphes sont ils différents   ? \n\n```{r,eval=FALSE,fig.show='hold',out.width='50%'}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth()\n\nggplot() + \n  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + \n  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))\n```\n* Refaire les graphes ci-dessous : \n\n```{r,echo=FALSE,fig.show='hold'}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +geom_smooth() +geom_point()\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))  +geom_smooth(aes(group=drv),se=F) +geom_point()\n```\n\n```{r,echo=FALSE,fig.show='hold'}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy,color=drv))  +geom_smooth(se=F) +geom_point()\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))  +geom_smooth(se=F) +geom_point(aes(color=drv))\n```\n\n```{r,echo=FALSE,fig.show='hold'}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))  +geom_smooth(se=F,aes(linetype=drv)) +geom_point(aes(color=drv))\nggplot(data = mpg, mapping = aes(x = displ, y = hwy))  +geom_smooth(se=F,aes(linetype=drv))+geom_point(size = 5, color=\"white\") +geom_point(aes(color=drv))\n\n```\n\n\n## Graphiques et statistiques\n\nNous allons étudier la géométrie `geom_bar()` en français des diagrammes en bâtons, rectangles. Cette géométrie est particulière comparée aux précédentes. Il y a en effet une transformation des données avant de les afficher sur un graphe. Nous allons prendre les données `diamonds`. Pour plus d'informations sur ces données tapez `?diamonds`.\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut))\n```\n\n**Question**  \n\n* Quel est l'axe des y ? Où se trouve les données de cet axe ? \n* Quelle est la différence par rapport aux scatterplots précédents ?\n\n![Schéma du graphe](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-stat-bar.png)\n\nCertaines géométries comme `geom_bar` utilisent des algorithmes pour calculer les nouvelles valeurs, que l'on nomme *stat* : \n\n* histogrammes (compte vos données par fréquence)\n* boîtes à moustache \n* `geom_smooth()` modélise vos données en direct sur le graphe \n\nIl y a plus de 20 stats dans ggplot2 à utiliser pour les découvrir, `?stat_bin`, `?stat_count`, `?stat_summary`.\n \n * Dès fois, la situation oblige à dessiner que des valeurs déjà calculées. `stat = \"identity\"`\n \n \n```{r}\ndemo <- data.frame(\n  a=seq(10,50,by=10),b= paste(\"bar\",seq(1,5)))\n\nggplot(data = demo) +\n  geom_bar(mapping = aes(x = b, y = a), stat = \"identity\")\n```\n* Vous avez besoin de calculer une métrique particulière :\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))\n```\n\n![ Les métriques possibles à calculer en fonction de chaque **stat**](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-stats.png)\n\n\n* On peut créer sa propre boîte à moustache\n\n```{r}\nggplot(data = diamonds) + \n  stat_summary(\n    mapping = aes(x = cut, y = depth),\n    fun.ymin = min,\n    fun.ymax = max,\n    fun.y = median\n  )\n```\n\n\n**Exercice 7**\n \n 1. Quel est l'équivalent géométrique de `stat_summary()` ? Modifiez le code ci-dessus en utilisant une fonction `geom_`.\n \n 2. Quelle est la différence entre les fonctions `stat_` et `geom_` ? Listez les paires entre les deux genres de fonctions.\n\n3. Quelle est le \"bug\" de ce graphique? Corrigez le.\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, y = ..prop..))\n\n```\n\n\n## Positions et couleurs des graphes \n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut,color=clarity))\n\n```\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut,fill=clarity))\n```\n\n**Question**\n\n* Quel est le problème avec les graphes précédents ? \n\nPour résoudre le problème de clarté des graphes précédents, nous pouvons utiliser l'argument `position` en-dehors de la fonction `aes()` \n\n**Position Stack**\nLa position par défaut du diagramme en bâton. \n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity)) +\n  ggtitle('Position = \"stack\"')\n```\n\n\n**Position Fill**\n\nCette ajustement permet plus facilement de comparer les proportions entre chaque groupe.\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"fill\") +\n  ggtitle('Position = \"fill\"')\n```\n\n\n**Position dodge**\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut, fill = clarity), position = \"dodge\") +\n  ggtitle('Position = \"dodge\"')\n```\n\n**Position Jitter**\n\n\n```{r,fig.show='hold',out.width='50%'}\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy), position = \"jitter\") + \n  ggtitle('Position = \"jitter\"')\n\nggplot(data = mpg) + \n  geom_point(mapping = aes(x = displ, y = hwy)) + \n  ggtitle('Position = \"No jitter\"')\n\n\n```\n\n**Exercice 8**\n\n1. Quel est le problème avec ce graphique ? Comment pouvez vous l'améliorer ?\n\n```{r}\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + \n  geom_point()\n\n```\n\n2. Quels sont les arguments de `geom_jitter()`?\n3. Comparer `geom_jitter()` et  `geom_count()` ?\n4. Recréer ces graphiques\n\n\n```{r,fig.show='hold',out.width = '50%',echo=FALSE}\nggplot(data = diamonds, mapping = aes( x= cut,y=depth)) +\n  geom_boxplot()\nggplot(data = diamonds, mapping = aes( x= cut,y=depth)) +\n  geom_jitter()\n\n```\n\n```{r,fig.show='hold',out.width = '50%',echo=FALSE}\nggplot(data = diamonds, mapping = aes( x= cut,y=depth)) +\n  geom_violin()\n\nggplot(data = diamonds, mapping = aes( x= cut,y=depth))+\n  geom_jitter(alpha=0.5)+ geom_violin(alpha=0.7)\n\n\n```\n\n5. A quelles valeurs/métriques correspondent les traits horizontaux de la boîte à moustache ? (Indice utiliser `stat_summary`)\n\n```{r,fig.show='hold',out.width='50%'}\nggplot(data = diamonds, mapping = aes(x=cut,y=depth)) +\ngeom_boxplot()\n\nggplot(data = diamonds, mapping = aes(x=cut,y=depth)) +\ngeom_boxplot()+\nstat_summary( color=\"red\", fun.ymin = min,\n    fun.ymax = max,\n    fun.y = median)\n```\n\n\n\n\n## Système de coordonnées \n\nNous pouvons changer les coordonnées cartésiennes en coordonnées polaires. Nous allons commencer par reprendre le  des diagrammes en colonnes. \n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut,fill=cut),colour=\"black\")\n```\nPuis nous allons ajouter la commande `coord_polar()`\n\n\n```{r}\nggplot(data = diamonds) + \n  geom_bar(mapping = aes(x = cut,fill=cut),colour=\"black\")+coord_polar()\n```\n\nNous pouvons rester dans les coordonnées cartésiennes et changer l'axe des x et des y facilement avec `coord_flip()`.\n\n\n```{r,fig.show='hold',out.width='50%'}\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot()\nggplot(data = mpg, mapping = aes(x = class, y = hwy)) + \n  geom_boxplot() +\n  coord_flip()\n```\n\n\n```{r,fig.show='hold'}\n#install.packages(\"maps\")\nfr <- map_data(\"france\")\n\nggplot(fr, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\")\n\nggplot(fr, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\n```\n\n\n\n\n![Aide mémoire coordonnées avec ggplot2](/home/mrrobot/Documents/FIN406_2017/Picture/coord.png)\n\n\n**Exercie 9**\n\n1. Dessinez le département et une région de votre choix ?\n\n2. Quelle est la différence entre `coord_map()` et `coord_quickmap()` ? \n\n\n## Themes et addins \n\nPour améliorer vos graphes : \n\n* Installer l'addin `devtools::install_url(\"https://cran.r-project.org/src/contrib/rgeos_0.3-22.tar.gz\")` https://github.com/calligross/ggthemeassist\n* Utiliser les thèmes prédéfinis \n\n\n**Exercice 10**\n\n1. Changer le thème du précédent graphes ?\n\n```{r,eval=FALSE}\nggplot(fr, aes(long, lat, group = group)) +\n  geom_polygon(fill = \"white\", colour = \"black\") +\n  coord_quickmap()\n```\n\n\n![Aide mémoire thèmes avec ggplot2](/home/mrrobot/Documents/FIN406_2017/Picture/visualization-themes.png)\n\n\n\n",
    "created" : 1487666125927.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "707140424",
    "id" : "D651DA66",
    "lastKnownWriteTime" : 1487673294,
    "last_content_update" : 1487673294098,
    "path" : "~/Documents/FIN406_2017/DataVisualisation.Rmd",
    "project_path" : "DataVisualisation.Rmd",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}